@ Yulissa Camacho Quirós
@ B91472

.data

.balign 4
randarray:              .skip       400
printf_str:     .asciz      "randarray[%d] = %d\n"
debug_str:
.asciz "R%-2d   0x%08X  %011d \n"
exit_str:       .ascii      "Programa terminado.\n"

.global main
.func main

	/*Bloque que llena un arreglo con números aleatorios
		generado tomando como guía el código 
		  de: Christopher D. McMurrough*/
   
main:
    BL seedrand             @ toma el método seedrand
    MOV R0, #0              @ inicializa índice de la variable
writeloop:
    CMP R0, #100            @ revisa que se haga la iteración
    BEQ writedone           @ termina el ciclo si está listo
    LDR R1, =randarray      @ busca el arreglo
    LSL R2, R0, #2          @ multiplica el índice * 4 para tener el desplazamiento del arreglo
    ADD R2, R1, R2          @ pasa el elemento a R2
    PUSH {R0}               @ respaldo del iterador antes de llamar al procedimiento
    PUSH {R2}               @ respaldo del elemento antes de llamar al procedimiento
    BL getrand              @ toma un número random
    POP {R2}                @ restaura elemento
    STR R0, [R2]            @ escribe randarray[i] 
    POP {R0}                @ restaura iterator
    ADD R0, R0, #1          @ incrementa ínidce
    B   writeloop           @ vuelve al ciclo
writedone:
    MOV R0, #0              @ inicializa índice de la variable
readloop:
    CMP R0, #100            @ revisa que se haga la iteración
    BEQ readdone            @ termina el ciclo si está listo
    LDR R1, =randarray      @ busca el arreglo
    LSL R2, R0, #2          @ multiplica el índice * 4 para tener el desplazamiento del arreglo
    ADD R2, R1, R2          @ pasa el elemento a R2
    LDR R1, [R2]            @ lee lo que tiene el arreglo
    PUSH {R0}               @ respaldo del registro antes de llamar al procedimiento
    PUSH {R1}               @ respaldo del registro antes de llamar al procedimiento
    PUSH {R2}               @ respaldo del registro antes de llamar al procedimiento
    MOV R2, R1              @ mueve el valor que tiene el arreglo a R2 para imprimirlo
    MOV R1, R0              @ mueve el ínidice del arreglo a R1 para imprimirlo
    BL  printf              @ llama al procedimiento que imprime
    POP {R2}                @ restaura registro
    POP {R1}                @ restaura registro
    POP {R0}                @ restaura registro
    ADD R0, R0, #1          @ incrementa el índice
    B   readloop            @ vuelve al ciclo
readdone:
    B exit                  @ sale si está listo
    
exit:  
    MOV R7, #4              
    MOV R0, #1              
    MOV R2, #21             @ print string length
    LDR R1, =exit_str       @ string at label exit_str:
    SWI 0                   @ hace llamada al sistema
    MOV R7, #1              @ termina llamada al sistema, 1
    SWI 0                   @ hace llamada al sistema
       
printf:
    PUSH {LR}               @ almacena retorno
    LDR R0, =printf_str     @ pasa string a RO
    BL printf               @ llama a printf
    POP {PC}                @ restaura el puntero de la pila
    
seedrand:
    PUSH {LR}               @ respaldo al retorno
    MOV R0, #0              @ pasa 0 para llamar a time
    BL time                 @ toma time
    MOV R1, R0              @ pasa time a srand
    BL srand                @ toma srand
    POP {PC}                @ retorna 
    
getrand:
    PUSH {LR}               @ respaldo al retorno
    BL rand                 @ roma el número aleatorio
    POP {PC}                @ retorna 
   
